(list.h)
#ifndef LIST_H_INCLUDED
#define LIST_H_INCLUDED

#include <iostream>
#include "my_data.h"

#define first(L) L.first
#define next(P) P->next
#define info(P) P->info

using namespace std;


/**
* Type infotype : mytype
* Type address  : pointer to ElmList
*
* Type ElmList <
*	info : infotype
*	next : address
* >
*
* Type List : < First : address >
*
**/



typedef mytype infotype;
typedef struct elmlist *address;

struct elmlist
{
    infotype info;
    address next;
};

struct List
{
    address first;
};



// define a function and a procedure to allocate and deallocate an element list
void createList(List &L);
address allocate(infotype x);
void deallocate(address &P);

// define insert and delete procedure
void insertFirst(List &L, address P);
void insertLast(List &L, address P);
void deleteFirst(List &L, address &P);
void deleteLast(List &L, address &P);
void insertAfter(List &L, address Prec, address P);
void deleteAfter(List&L, address Prec, address &P);

// define search-by-ID function and view procedure
address findElm(List L, infotype x);
void printInfo(List L);


#endif // LIST_H_INCLUDED

(list.cpp)
#include "list.h"
#include "my_data.h"

void createList(List &L)
{
    /**
    * FS : set first(L) with Null
    */
    first(L) = NULL;
}

address allocate(infotype x)
{
    /**
    * FS : return new list element with info = x and next element is Null
    */

    address P = new elmlist;
    info(P) = x;
    next(P) = NULL;
    return P;
}

void deallocate(address &P)
{
    /**
    * FS : delete element pointed by P
    */
    delete P;
}

void insertFirst(List &L, address P)
{
    /**
    * IS : List L may be empty
    * FS : element pointed by P became the first element in List L
    */
    if (first(L) == NULL)
    {
        first(L) = P;
    }
    else
    {
        next(P) = first(L);
        first(L) = P;
    }
}

void insertLast(List &L, address P)
{
    /**
    * IS : List L may be empty
    * FS : element pointed by P became the last element in List L
    */
    if (first(L) == NULL)
    {
        insertFirst(L, P);
    }
    else
    {
        address Q = first(L);
        while (next(Q) != NULL)
        {
            Q = next(Q);
        }
        next(Q) = P;
    }
}

address findElm(List L, infotype x)
{
    /**
    * IS : List L may be empty
    * FS : returns element with info.ID = x.ID,
           return Null if such ID is not found
    */

    address P;
    P = first(L);
    while (x.id != info(P).id && P != NULL)
    {
        P = next(P);
    }
    return P;
}

void deleteFirst(List &L, address &P)
{
    /**
    * IS : List L may be empty
    * FS : first element in List L is removed and is pointed by P
    */
    if(first(L) != NULL)
    {
        if(next(first(L)) == NULL)
        {
            P = first(L);
            first(L) = NULL;
        }
        else
        {
            P = first(L);
            first(L) = next(P);
            next(P) = NULL;
        }
    }
}

void deleteLast(List &L, address &P)
{
    /**
    * IS : List L may be empty
    * FS : last element in List L is removed and is pointed by P
    */
    if (first(L) != NULL)
    {
        P = first(L);
        while (next(next(P)) != NULL)
        {
            P = next(P);
        }
        next(P) = NULL;
    }
}

void printInfo(List L)
{
    /**
    * FS : view info of all element inside List L,
    *      call the view_data function from my_data.h to print the info
    */
    if (first(L) == NULL)
    {
        cout << "Data Kosong \n";
    }
    else
    {
        address P = first(L);
        while (P != NULL)
        {
            view_data(info(P));
            P = next(P);
        }
    }
}


void insertAfter(List &L, address Prec, address P)
{
    /**
    * IS : Prec and P is not NULL
    * FS : element pointed by P is placed behind the element
    *      pointed by pointer Prec
    */
    if((P != NULL) && (Prec != NULL))
    {
        next(P) = next(Prec);
        next(Prec) = P;
    }

}
void deleteAfter(List &L, address Prec, address &P)
{
    /**
    * IS : Prec is not NULL
    * FS : element which was before behind an element pointed by Prec
    *      is removed and pointed by pointer P
    */
    if(Prec != NULL)
    {
        P = next(Prec);
        next(Prec) = next(P);
        next(P) = NULL;
    }
}

(my_data.h)
#ifndef MY_DATA_H_INCLUDED
#define MY_DATA_H_INCLUDED

#include <iostream>
using namespace std;

/**
    CLASS      : IF 42-04
    NAME       : Ilham Rizki Hidayat
    STUDENT ID : 1301184123
**/

struct mytype
{
    /**
     TODO:  create a new Data type with specification:
            - an integer variable acted as an ID
            - string name
            - integer rank
            - float score
    */
    int id;
    string nama;
    int ranking;
    float score;
};


mytype create_data();
void view_data(mytype d);
void edit_data(mytype &d);

#endif // MY_DATA_H_INCLUDED

(my_data.cpp)
#include "my_data.h"

/**
CLASS      :
IF 42-04
NAME       :
Ilham Rizki Hidayat
STUDENT ID : 1301184123
**/

mytype create_data()
{
    /**
     TODO:  receive input FROM USER
            and assign the value of new data
    */
    mytype d;
    cout << "Masukan ID : ";
    cin >> d.id;
    cout << "Masukan Nama : ";
    cin >> d.nama;
    cout << "Masukan Peringkat : ";
    cin >> d.ranking;
    cout << "Masukan Skor : ";
    cin >> d.score;
    return d;
}

void view_data(mytype d)
{
    /**
     TODO:  view the content of data d
     it will be called when print_info function is invoked
    */
    cout << "\n=======================================\n";
    cout << "ID : " << d.id << endl;
    cout << "Nama : " << d.nama << endl;
    cout << "Peringkat : " << d.ranking << endl;
    cout << "Skor : " << d.score << endl;
    cout << "=======================================\n";
}


void edit_data(mytype &d)
{
    /**
     * TODO:  edit the value of data d,
     *       receive input FROM USER
     *       the ID must NOT be modified
    */
    cout << "Nama : ";
    cin >> d.nama;
    cout << "Peringkat : ";
    cin >> d.ranking;
    cout << "Skor : ";
    cin >> d.score;
}

(operation.h)
#ifndef OPERATION_H_INCLUDED
#define OPERATION_H_INCLUDED

#include "list.h"

void insertAndSort(List &L, infotype x);

void deletebyID(List &L, int id_x);

void savePassedMember(List &L, List &L2);


#endif // OPERATION_H_INCLUDED

(operation.cpp)
#include "list.h"
#include "operation.h"
#include "my_data.h"


void insertAndSort(List &L, infotype x)
{
    /**
    * IS : List may be empty
    * PR : insert a new element into an already sorted-by-ID List L
    *      so that the elements inside List L is still sorted by ID.
    *      procedure must also check if such ID is already exists (No Duplicate ID).
    *      If new data has duplicate ID, new data is rejected.
    * FS : elements in List L sorted by ID, P is inside List L
    */
    address P;
    P = allocate(x);
    if (first(L)== NULL)
    {
        insertFirst(L,P);
    }
    else
    {
        address Q = findElm(L, info(P));
        if (Q == NULL)
        {
            address last = first(L);
            while (next(last)!= NULL)
            {
                last = next(last);
            }

            if (info(P).id <= info(first(L)).id)
            {
                insertFirst(L,P);
            }
            else if (info(P).id >= info(last).id)
            {
                insertLast(L,P);
            }
            else
            {
                Q = first(L);
                while (info(next(Q)).id < info(P).id)
                {
                    Q = next(Q);
                }
                insertAfter(L,Q,P);
            }
        }
        else
        {
            cout << "Duplikat";
        }
    }
}


void deletebyID(List &L, int id_x)
{
    /**
    * IS : List L may be empty
    * FS : an element with ID info = id_x is deleted from List L (deallocate)
    */
    address Prec, P;
    infotype x;
    x.id = id_x;
    P = findElm(L, x);
    if (P == NULL)
    {
        cout << "ID tidak ditemukan.\n";
    }
    else
    {
        if (P == first(L))
        {
            deleteFirst(L, P);
        }
        else if (next(P) == NULL)
        {
            deleteLast(L, P);
        }
        else
        {
            Prec = first(L);
            while(next(Prec) != P)
            {
                Prec = next(Prec);
            }
            deleteAfter(L, Prec, P);
        }
    }
}


void savePassedMember(List &L, List &L2)
{
    /**
    * IS : List L and L2 may be empty
    * FS : any element with score greater than 80 is moved to L2
    */
    address P;
    P = first(L);
    while (P != NULL)
    {
        if (info(P).score > 80)
        {
            insertFirst(L2, P);
        }
        P = next(P);
    }
}
